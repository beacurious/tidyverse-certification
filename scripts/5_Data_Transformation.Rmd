---
title: "Chapter 5: Data Transformation"
author: "Belinda Fabian"
date: "03/11/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "..") 
# change working directory for all code chunks to the project working directory
```

# 5.1 Introduction

transforming data using the dplyr package and dataset on flights departing New York City in 2013

## 5.1.1 Prerequisites

```{r load packages, echo = TRUE, results = "hide", error = FALSE, warning = FALSE, message = FALSE}
library(tidyverse)
library(nycflights13)
```

message that’s printed when load the tidyverse - dplyr overwrites some functions in base R

## 5.1.2 nycflights13

explore the basic data manipulation verbs of dplyr using `nycflights13::flights`

data frame contains all 336,776 flights that departed from New York City in 2013
data comes from the US Bureau of Transportation Statistics, and is documented in `?flights`

this datafram is a tibble --> shows the first few rows and all the columns that fit on one screen
Tibbles are data frames, but slightly tweaked to work better in the tidyverse
more detail in chapter 10
```{r}
nycflights13::flights
```

row of 3 (or 4) letter abbreviations under column names describes the type of each variable:
*`int` stands for integers
*`dbl` stands for doubles, or real numbers
*`chr` stands for character vectors, or strings
*`dttm` stands for date-times (a date + a time)

three other common types of variables will encounter later:
*`lgl` stands for logical, vectors that contain only TRUE or FALSE
*`fctr` stands for factors, R uses to represent categorical variables with fixed possible values
*`date` stands for dates

## 5.1.3 dplyr basics

5 key dplyr functions that can solve the vast majority of data manipulation challenges:
*Pick observations by their values (`filter()`)
*Reorder the rows (`arrange()`)
*Pick variables by their names (`select()`)
*Create new variables with functions of existing variables (`mutate()`)
*Collapse many values down to a single summary (`summarise()`)

These can all be used in conjunction with `group_by()` which changes the scope of each function from operating on the entire dataset to operating on it group-by-group. These six functions provide the verbs for a language of data manipulation.

All verbs work similarly:
*The first argument is a data frame
*The subsequent arguments describe what to do with the data frame, using variable names (no quotes)
*The result is a new data frame

These properties make it easy to chain together multiple simple steps to achieve a complex result

dplyr functions never modify their inputs, so if want to save the result, need to use the assignment operator to store the result in a new variable

R either prints out the results, or saves them to a variable -->if want both, wrap assignment in parentheses

# 5.2 Filter rows with `filter()`

`filter()` allows you to subset observations based on their values
The first argument is the name of the data frame. The second and subsequent arguments are the expressions that filter the data frame. 

```{r}
#select all flights on 1 January

names(flights)
flights

filter(flights, month == 1, day == 1)
```

## 5.2.1 Comparisons

comparison operators: `>`, `>=`, `<`, `<=`, `!=` (not equal), `==` (equal)

common problem you might encounter when using `==` is floating point numbers
--> computers use finite precision arithmetic so remember that every number is an approximation


```{r}
# weird results when using ==
sqrt(2) ^ 2 == 2
1 / 49 * 49 == 1

# use near() instead
near(sqrt(2) ^ 2, 2)
near(1 / 49 * 49, 1)
```

## 5.2.2 Logical operators

Multiple arguments to filter() are combined with “and” --> see example of flights on 1 Jan above
Every expression must be true in order for a row to be included in the output

For other types of combinations, need to use Boolean operators: 
*`&` is “and” 
*`|` is “or”
*`!` is “not”

```{r}
# flights that departed in Nov and Dec --> using logical operator OR
filter(flights, month == 11 | month == 12)

# flights that departed in Nov and Dec --> using x %in% y
filter(flights, month %in% c(11, 12))
```

As well as & and |, R also has && and ||. Don’t use them here! Learn more in 19.4 conditional execution

If using complicated, multipart expressions in filter(), consider making them explicit variables instead --> makes it much easier to check work


## 5.2.3 Missing values

Comparisons can be tricky when there are NAs --> anything that involves NAs will likely be NA

To find out if there are NAs present use `is.na(x)`

Filter() only includes rows where the condition is TRUE; it excludes both FALSE and NA values
If want to preserve missing values, ask for them explicitly

```{r}
# create df with one column of three observations
df <- tibble(x = c(1, NA, 3))

# without asking for NAs
filter(df, x > 1)

# with asking for NAs
filter(df, is.na(x) | x > 1)
```


## 5.2.4 Exercises

1. Find all flights that

```{r}
names(flights)

# Had an arrival delay of two or more hours
filter(flights, arr_delay >= 120)

# Flew to Houston (IAH or HOU)
filter(flights, dest %in% c("IAH", "HOU"))

# Were operated by United, American, or Delta
filter(flights, carrier %in% c("UA", "AA", "DL"))

# Departed in summer (July, August, and September)
filter(flights, month %in% c(7:9))

# Arrived more than two hours late, but didn’t leave late
filter(flights, dep_delay <= 0, arr_delay > 120)

# Were delayed by at least an hour, but made up over 30 minutes in flight
filter(flights, dep_delay >= 60, arr_delay < (dep_delay - 30)) # my answer
filter(flights, dep_delay >= 60, dep_delay - arr_delay > 30) # exercises answer

# Departed between midnight and 6am (inclusive)
filter(flights, dep_time == 2400 | dep_time <= 600)

```


2. Another useful dplyr filtering helper is between(). What does it do? Can you use it to simplify the code needed to answer the previous challenges?

--> this function returns values that fall between and including the nominated x and y values, (x and y are arguments of `between()`)

```{r}
?between()

# Departed in summer (July, August, and September)
flights %>% 
  filter(between(month, 7, 9))

# Departed between midnight and 6am (inclusive)
flights %>% 
  filter(!between(dep_time, 601, 2359))

```


3. How many flights have a missing dep_time? What other variables are missing? What might these rows represent?

8255 flights have no departure time
These flights also have no arrival time, air time
These likely represent cancelled flights

```{r}
flights %>% 
  filter(is.na(dep_time))
```


4. Why is NA ^ 0 not missing? Why is NA | TRUE not missing? Why is FALSE & NA not missing? Can you figure out the general rule? (NA * 0 is a tricky counterexample!)

```{r}
NA ^ 0 # this does not give an NA answer as anything to the power of 0 equals 1 (must be treating NA as a numeric value)

NA | TRUE # this does not give an NA answer as there is something there so it can't be false

FALSE & NA # this does not give an NA answer as there is something there (not an NA) so it can't be true

```


# 5.3 Arrange rows with `arrange()`

`arrange()` changes row order
takes a data frame and a set of column names (or more complicated expressions) to order by
if provide >1 column name, each extra column used to break ties in the values of preceding columns

using `arrange()` alone sorts in ascending order
Use `desc()` to sort in descending order
Missing observations (NAs) are always placed at the end 


```{r}
arrange(flights, year, month, day)

arrange(flights, dep_delay)

```

## 5.3.1 Exercises

1. How could you use arrange() to sort all missing values to the start? (Hint: use is.na()).

```{r}
arrange(flights, desc(is.na(dep_time)), dep_time)
```


2. Sort flights to find the most delayed flights. Find the flights that left earliest.

```{r}
# most delayed flights
arrange(flights, desc(dep_delay))

# flights that left earliest (compared to their scheduled departure time)
arrange(flights, dep_delay)

```

3. Sort flights to find the fastest (highest speed) flights.

```{r}
arrange(flights, air_time)
```


4. Which flights travelled the farthest? Which travelled the shortest?

```{r}
# travelled the farthest distance
arrange(flights, desc(distance))

# travelled the shortest distance
arrange(flights, distance)
```

# 5.4 Select columns with `select()`



## 5.4.1 Exercises


# 5.5 Add new variables with `mutate()`

## 5.5.1 Useful creation functions

## 5.5.2 Exercises


# 5.6 Grouped summaries with `summarise()`

## 5.6.1 Combining multiple operations with pipe

## 5.6.2 Missing values

## 5.6.3 Counts

## 5.6.4 Useful summary functions

## 5.6.5 Grouping by muliple variables

## 5.6.6 Ungrouping

## 5.6.7 Exercises


# 5.7 Grouped mutates (and filters) 

## 5.7.1 Exercises


